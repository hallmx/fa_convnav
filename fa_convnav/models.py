# AUTOGENERATED! DO NOT EDIT! File to edit: 02_models.ipynb (unless otherwise specified).

__all__ = ['vgg', 'alexnet', 'squeezenet', 'resnet', 'densenet', 'xresnet', 'models', 'find_model', 'supported_models',
           'get_base_row', 'models_test']

# Cell

# Supported pretrained models (name, num layers)

vgg = [('vgg11_bn', 44),
        ('vgg13_bn', 50),
        ('vgg16_bn', 59),
        ('vgg19_bn', 68)]

alexnet = [('alexnet', 28)]

squeezenet = [('squeezenet1_0', 76),
               ('squeezenet1_1',76 )]

resnet = [('resnet18', 79),
           ('resnet34', 127),
           ('resnet50', 162),
           ('resnet101', 298),
           ('resnet151', 434)]

densenet = [('densenet121', 445),
             ('densenet161', 585),
             ('densenet169', 613),
             ('densenet201', 725)]

xresnet = [('xresnet101', 541),
            ('xresnet152', 796),
            ('xresnet18', 131),
            ('xresnet18_deep', 160),
            ('xresnet18_deeper', 164),
            ('xresnet34', 219),
            ('xresnet34_deep', 248),
            ('xresnet34_deeper', 274),
            ('xresnet50', 286),
            ('xresnet50_deep', 323),
            ('xresnet50_deeper', 357)]


# Cell
# List of dicts containing model type and list of (model name, num layer) tuples
models = [{'vgg': vgg},
          {'alexnet': alexnet},
          {'squeezenet': squeezenet},
          {'resnet': resnet},
          {'densenet': densenet},
          {'xresnet': xresnet}]

# Cell
def find_model(n=None):
  "Returns tuple of model type and name given number layers (n)"
  for d in models:
    match = [(k, m) for k, v in d.items() for m, l in v if l == n]
    if match != []: break
  if len(match) > 0: return match[0] # (model_grp, model_name)
  assert True, 'Model not supported. Type supported_models() to get a list of supported models.'

# Cell
def supported_models(models):
  "Prints list of supported models from 'models' list"
  print('Supported models')
  print('================\n')
  for d in models:
      [[print(m) for m, l in v] for k, v in d.items()]

# Cell
# alexnet, vgg
def get_base_row(l):
  "Construct a dataframe row from the information in a singel layer(l) returned by fastai's 'model.named_modules' method"

  layer_name = l[0]
  ln_split = str(layer_name).split('.')
  ln_n_splits = len(ln_split)
  div_id = ln_split[0] if ln_n_splits >0 else ''
  mod_id = ln_split[1] if ln_n_splits >1 else ''
  blk_id = ''
  typ_id = ln_split[3] if ln_n_splits >3 else ''

  tch_cls_str = str(type(l[1]))
  tch_cls_substr =  tch_cls_str[tch_cls_str.find("<class")+8: tch_cls_str.find(">")-1]
  tch_cls = tch_cls_substr.split('.')[-1]

  lyr_obj = l[1]
  lyr_str = str(lyr_obj)

  def get_div():
    if layer_name == '0' or layer_name == '1': return tch_cls
    return ''

  def get_mod():
    if ln_n_splits == 2: return tch_cls
    return ''

  def get_lyr():
    return lyr_str[:90]

  return {
      'Layer_name': layer_name,
      'Model': tch_cls if layer_name == '' else '',
      'Division': get_div(),
      'Module': get_mod(),
      'Block': '',
      'Layer': get_lyr(),
      'Torch_class': tch_cls_substr,
      'Output_dimensions': '',
      'Parameters': '',
      'Trainable': '',
      'Currently': '',
      'div_id': div_id,
      'modu_id': mod_id,
      'blk_id': blk_id,
      'typ_id': typ_id,
      'tch_cls': tch_cls,
      'out_dim': '',
      'current': '',
      'lyr_blk': '',
      'lyr_mod': '',
      'blk_mod': '',
      'lyr_obj': lyr_obj
      }

# Cell
def models_test(test):
  "Models"
  print(test)