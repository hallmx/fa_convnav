# AUTOGENERATED! DO NOT EDIT! File to edit: 01_navigator.ipynb (unless otherwise specified).

__all__ = ['CNDFView', 'CNDFSearch', 'ConvNav', 'save_cndf', 'load_cndf']

# Cell
import gzip, pickle
from .models import models
from .core import *
from pandas import DataFrame, option_context

# Cell
class CNDFView:
  "Class to view a CNDF dataframe"

  def copy_layerinfo(self, df):
    "Copy layer information and block/layer counts across from hidden columns to displayed columns"
    df.loc[df['Division'] == '', 'Division'] = df['div_id']
    df.loc[df['Container_child'] == '', 'Container_child'] = df['chd_id']
    df.loc[df['Container_block'] == '', 'Container_block'] = df['blk_id']
    df.loc[df['Output_dimensions'] == '', 'Output_dimensions'] = df['out_dim']
    df.loc[df['Currently'] == '', 'Currently'] = df['current']
    return df

  def check_view_args(self, df, truncate, verbose):
    "Check arguments given to view function, `df`, `truncate` and `verbose` are valid"
    assert type(df) == DataFrame and 'Module_name' in df.columns, "Not a valid convnav dataframe"
    assert isinstance(truncate, int) and -10 <= truncate <= 10, f"Argument 'truncate' must be an integer between -10 (show more cols) and +10 (show fewer cols)"
    assert isinstance(verbose, int) and 1 <= verbose <= 5, f"Argument verbose must be 1 2 or 3 "

  def view(self, df=None, verbose=3, tight=True, truncate=0, align_cols='left', top=False, show=True, return_df=False):
    "Display dataframe `df` with optional arguments and styling"

    if not show: return None
    _df = df if df is not None else self._cndf.copy()
    self.check_view_args(_df, truncate, verbose)

    if not isinstance(tight, bool): tight = True
    if len(_df) < 10: tight = False
    if verbose != 3: truncate = (10, 4, 0, 0, -10)[verbose-1]
    if verbose == 4: _df = self.copy_layerinfo(_df)

    post_msg = ''
    if top and len(_df) > 10:
      post_msg = f'...{len(_df)-10} more layers'
      _df = _df.iloc[:10]
      tight=False

    if len(_df) == 0:
      print('No data to display')
      return None

    with option_context("display.max_rows", 1000):
      _df.index.name = 'Index'
      _df_styled = _df.iloc[:,:-(11+truncate)].style.set_properties(**{'text-align': align_cols})
      if tight:
        display(_df_styled)
      else:
        display(_df.iloc[:,:-(11+truncate)])
    print(post_msg)
    if return_df and df is not None: return(_df)

  def copy_view(self, df, **kwargs):
    "Copy over layer information then call `view` to display dataframe"
    df = self.copy_layerinfo(df)
    self.view(df=df, **kwargs)

# Cell
class CNDFSearch:
  "Class to search a CNDF dataframe, display the results in a dataframe and returns matching module object(s)"

  def _find_layer(self, df, searchterm, exact):
    "Searches `df` for `searchterm`, returning exact matches only if `exact=True` otherwise any match"

    if isinstance(searchterm, int):
      assert searchterm >= 0 and searchterm <= len(df), f'Layer ID out of range: min 0, max {len(df)}'
      #select 'df' row using index from 'searchterm'
      x = df.iloc[searchterm].copy()
      x = DataFrame(x).transpose()
      return x

    #if searchterm is a float assume it is a layer name (i.e. format 0.0.1) and convert to string
    if isinstance(searchterm, float): searchterm = str(searchterm)

    if isinstance(searchterm, dict):
      #select rows matching the conditional df[key] ==/contains value (exact=True/false) for dict
      for col, s in searchterm.items():
        assert col in df.columns, f'{col} not a valid column identifier. Valid column names are {df.columns}'
        return df[df[col] == s].copy() if exact else df[df[col].str.contains(s)].copy()
      return x

    if isinstance(searchterm, str):
      #select rows in df where df[col] ==/contains searchterm string (exact=True/False)
      #returns results after first matches are found in a column (remining columns not searched)
      searchterm = searchterm.strip(' \.')
      cols = {'Module_name', 'Torch_class', 'Division', 'Container_child', 'Container_block', 'Layer_description'}
      if exact:
        for col in cols:
          x = df[df[col] == searchterm].copy()
          if not x.empty: return x
      else:
        for col in cols:
          x = df[df[col].str.contains(searchterm)].copy()
          if not x.empty: return x
      return x

    assert True, 'Unrecognizable searchterm'

  def search(self, searchterm, df=None, exact=True, show=True):
    "Search 'df` for single or combination of modules and layers. If df = None, searches instance dataframe `self._cndf` (default)"
    if df is not None:
      _df = df.copy()
    else:
       _df = df = self._cndf.copy()

    if isinstance(searchterm, float): searchterm = str(searchterm)

    if isinstance(searchterm, int):
      _df = self._find_layer(_df, searchterm, True)

    elif isinstance(searchterm, str):
      _df = self._find_layer(_df, searchterm, exact)

    elif isinstance(searchterm, dict):
      #concatenate successive search results (logical 'OR') for series of dicts
      _df = DataFrame()
      for col, s in searchterm.items():
        new_df = self._find_layer(df, {col:s}, exact)
        _df = pd.concat((_df, new_df), axis=0, ignore_index=False).drop_duplicates('Module_name')

    elif isinstance(searchterm, list):
      #concatenate successive search results (logical 'OR') in list
      _df = DataFrame()
      for s in searchterm:
        new_df = self._find_layer(df, s, exact)
        _df = pd.concat((_df, new_df), axis=0, ignore_index=False).drop_duplicates('Module_name')

    elif isinstance(searchterm, tuple):
      #recursively call find_layer on _df to logical 'AND' successive search results in tuple
      for s in searchterm:
        _df = self._find_layer(_df, s, exact)

    else: assert True, 'Unrecognizable searchterm'

    #show matches and return corresponding modules
    if _df is not None and not _df.empty:
      if show:
        print(f'{len(_df)} layers found matching searchterm(s): {searchterm}\n')
        self.view(df=_df)
      return _df['lyr_obj'].tolist()
    else:
      if show: print(f'No matches for searchterm(s): {searchterm}\n')
      return None

# Cell
class ConvNav(CNDF, CNDFSearch, CNDFView):
  "Class to view fastai supported CNNs, search and select module(s) and layer(s) for further investigation. Automatically builds a CNDF dataframe from Learner and Learner.summary()"
  def __init__(self, learner, learner_summary):
    super().__init__(learner, learner_summary)

  def __len__(self):
    return len(self._cndf)

  def __str__(self) -> str:
    return self.model_info

  def __call__(self):
    self.view(head=True)

  def __contains__(self, s):
    return self.search(s)

  @property
  def head(self):
    "Print `model` head summary info and modules"
    df = self._cndf.copy()
    df = df[df['Module_name'].str.startswith('1')]
    if not df.empty:
      res = f"{self.model_type.capitalize()}: {self.model_name.capitalize()}\n"
      res += f"Input shape: {self._cndf.iloc[1]['out_dim']} (bs, filt, h, w)\n"
      res += f"Output features: {self.output_dimensions} (bs, classes)\n"
      print(res)
      self.view(df, truncate=1)
    else:
      res = "Model has no head"
      print(res)

  @property
  def body(self):
    "Print `model` body summary info and modules"
    df = self._cndf.copy()
    df = df.loc[df['Module_name'].str.startswith('0')]
    if not df.empty:
      res = f"{self.model_type.capitalize()}: {self.model_name.capitalize()}\n"
      res += f"Input shape: {self.input_sizes} (bs, ch, h, w)\n"
      res += f"Output dimensions: {df.iloc[-1]['Output_dimensions']} (bs, filt, h, w)\n"
      res += f"Currently frozen to parameter group {self.frozen_to} out of {self.num_param_groups}\n"
      print(res)
      self.view(df)
    else:
      res = "Model body has no contents"
      print(res)

  @property
  def divs(self):
    "Print Summary information from `model` head and body"
    df = self._cndf[(self._cndf['Module_name'] == '0') | (self._cndf['Module_name'] == '1')].copy()

    for i in range(2):
      df_div = self._cndf.loc[self._cndf['div_id'] == str(i)].copy()
      df.iloc[i]['Model'] = self.model_name
      df.iloc[i]['Container_child'] = len(df_div[df_div['Container_child'] != ''])
      df.iloc[i]['Container_block'] = len(df_div[df_div['Container_block'] != ''])
      df.iloc[i]['Layer_description'] = len(df_div[df_div['Layer_description'] != ''])
      params = df_div['Parameters'].values
      params_summed = sum(filter(lambda i: isinstance(i, int), params))
      df.iloc[i]['Parameters'] = params_summed

    df['Output_dimensions'] = df['out_dim']
    df.iloc[0]['Currently'] = df.iloc[0]['current']

    df = df.rename(columns={'Container_child': 'Child modules', 'Container_block': 'Blocks', 'Layer_description': 'Layers'})
    print(f"{self.model_name.capitalize()}\nDivisions:  body (0), head (1)\n")
    self.view(df, tight=False)

  @property
  def dim_transitions(self):
    "Finds layers with different input and output dimensions. These are useful points to apply hooks and callbacks for investigating model activity."
    df = self._cndf[self._cndf['Torch_class'].str.contains('Conv2d')].copy()

    n = []
    old_dims = 0
    for i, row in enumerate(df.iterrows()):
      row=row[1]
      new_dims = row['Output_dimensions'].rstrip(']').split(' x ')[-1]
      if new_dims != old_dims:
        n.append(i)
        old_dims = new_dims
    df = df.iloc[n]

    print(f"{self.model_name.capitalize()}\nLayer dimension changes\n")
    self.copy_view(df, tight=False)
    return df['lyr_obj'].tolist()

  @property
  def linear_layers(self):
    "Prints and returns all linear layers in the `model`"
    df = self._cndf[self._cndf['Torch_class'].str.contains('Linear')].copy()
    df['Division'] = df['div_id']

    print(f"{self.model_name.capitalize()} linear layers\n")
    self.view(df, truncate=1, tight=False)
    return df['lyr_obj'].tolist()

# Cell
def save_cndf(cn, filename, path='', with_modules=False):
  "Saves a CNDF dataframe of the ConvNav instance `cn` to persistent storage at `path` with `filename` gzip compresseed"
  df = cn._cndf.copy()
  if not with_modules: df = df.iloc[:,:-1]
  with gzip.open(path+filename, "wb") as f:
    pickle.dump(df, f, pickle.HIGHEST_PROTOCOL)

# Cell
def load_cndf(filename, path=''):
  "Loads a CNDF dataframe from persistent storage at `path`+`filename` and unzips it."
  with gzip.open(path+filename, "rb") as f:
    return pickle.load(f)